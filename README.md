## 과제 체크포인트

### 배포 링크

https://jumoooo.github.io/front_7th_chapter2-1/

### 기본과제

#### 상품목록

**상품 목록 로딩**

- [x] 페이지 접속 시 로딩 상태가 표시된다
- [x] 데이터 로드 완료 후 상품 목록이 렌더링된다
- [x] 로딩 실패 시 에러 상태가 표시된다
- [x] 에러 발생 시 재시도 버튼이 제공된다

**상품 목록 조회**

- [x] 각 상품의 기본 정보(이미지, 상품명, 가격)가 카드 형태로 표시된다

**한 페이지에 보여질 상품 수 선택**

- [x] 드롭다운에서 10, 20, 50, 100개 중 선택할 수 있으며 기본 값은 20개 이다.
- [x] 선택 변경 시 즉시 목록에 반영된다

**상품 정렬 기능**

- [x] 상품을 가격순/이름순으로 오름차순/내림차순 정렬을 할 수 있다.
- [x] 드롭다운을 통해 정렬 기준을 선택할 수 있다
- [x] 정렬 변경 시 즉시 목록에 반영된다

**무한 스크롤 페이지네이션**

- [x] 페이지 하단 근처 도달 시 다음 페이지 데이터가 자동 로드된다
- [x] 스크롤에 따라 계속해서 새로운 상품들이 목록에 추가된다
- [x] 새 데이터 로드 중일 때 로딩 인디케이터와 스켈레톤 UI가 표시된다
- [x] 홈 페이지에서만 무한 스크롤이 활성화된다

**상품을 장바구니에 담기**

- [x] 각 상품에 장바구니 추가 버튼이 있다
- [x] 버튼 클릭 시 해당 상품이 장바구니에 추가된다
- [x] 추가 완료 시 사용자에게 알림이 표시된다

**상품 검색**

- [x] 상품명 기반 검색을 위한 텍스트 입력 필드가 있다
- [x] 검색 버튼 클릭으로 검색이 수행된다
- [x] Enter 키로 검색이 수행된다
- [x] 검색어와 일치하는 상품들만 목록에 표시된다

**카테고리 선택**

- [x] 사용 가능한 카테고리들을 선택할 수 있는 UI가 제공된다
- [x] 선택된 카테고리에 해당하는 상품들만 표시된다
- [x] 전체 상품 보기로 돌아갈 수 있다
- [x] 2단계 카테고리 구조를 지원한다 (1depth, 2depth)

**카테고리 네비게이션**

- [x] 현재 선택된 카테고리 경로가 브레드크럼으로 표시된다
- [x] 브레드크럼의 각 단계를 클릭하여 상위 카테고리로 이동할 수 있다
- [x] "전체" > "1depth 카테고리" > "2depth 카테고리" 형태로 표시된다

**현재 상품 수 표시**

- [x] 현재 조건에서 조회된 총 상품 수가 화면에 표시된다
- [x] 검색이나 필터 적용 시 상품 수가 실시간으로 업데이트된다

#### 장바구니

**장바구니 모달**

- [x] 장바구니 아이콘 클릭 시 모달 형태로 장바구니가 열린다
- [x] X 버튼이나 배경 클릭으로 모달을 닫을 수 있다
- [x] ESC 키로 모달을 닫을 수 있다
- [x] 모달에서 장바구니의 모든 기능을 사용할 수 있다

**장바구니 수량 조절**

- [x] 각 장바구니 상품의 수량을 증가할 수 있다
- [x] 각 장바구니 상품의 수량을 감소할 수 있다
- [x] 수량 변경 시 총 금액이 실시간으로 업데이트된다

**장바구니 삭제**

- [x] 각 상품에 삭제 버튼이 배치되어 있다
- [x] 삭제 버튼 클릭 시 해당 상품이 장바구니에서 제거된다

**장바구니 선택 삭제**

- [x] 각 상품에 선택을 위한 체크박스가 제공된다
- [x] 선택 삭제 버튼이 있다
- [x] 체크된 상품들만 일괄 삭제된다

**장바구니 전체 선택**

- [x] 모든 상품을 한 번에 선택할 수 있는 마스터 체크박스가 있다
- [x] 전체 선택 시 모든 상품의 체크박스가 선택된다
- [x] 전체 해제 시 모든 상품의 체크박스가 해제된다

**장바구니 비우기**

- [x] 장바구니에 있는 모든 상품을 한 번에 삭제할 수 있다

#### 상품 상세

**상품 클릭시 상세 페이지 이동**

- [x] 상품 목록에서 상품 이미지나 상품 정보 클릭 시 상세 페이지로 이동한다
- [x] URL이 `/product/{productId}` 형태로 변경된다
- [x] 상품의 자세한 정보가 전용 페이지에서 표시된다

**상품 상세 페이지 기능**

- [x] 상품 이미지, 설명, 가격 등의 상세 정보가 표시된다
- [x] 전체 화면을 활용한 상세 정보 레이아웃이 제공된다

**상품 상세 - 장바구니 담기**

- [x] 상품 상세 페이지에서 해당 상품을 장바구니에 추가할 수 있다
- [x] 페이지 내에서 수량을 선택하여 장바구니에 추가할 수 있다
- [x] 수량 증가/감소 버튼이 제공된다

**관련 상품 기능**

- [x] 상품 상세 페이지에서 관련 상품들이 표시된다
- [x] 같은 카테고리(category2)의 다른 상품들이 관련 상품으로 표시된다
- [x] 관련 상품 클릭 시 해당 상품의 상세 페이지로 이동한다
- [x] 현재 보고 있는 상품은 관련 상품에서 제외된다

**상품 상세 페이지 내 네비게이션**

- [x] 상품 상세에서 상품 목록으로 돌아가는 버튼이 제공된다
- [x] 브레드크럼을 통해 카테고리별 상품 목록으로 이동할 수 있다
- [x] SPA 방식으로 페이지 간 이동이 부드럽게 처리된다

#### 사용자 피드백 시스템

**토스트 메시지**

- [x] 장바구니 추가 시 성공 메시지가 토스트로 표시된다
- [x] 장바구니 삭제, 선택 삭제, 전체 삭제 시 알림 메시지가 표시된다
- [x] 토스트는 3초 후 자동으로 사라진다
- [x] 토스트에 닫기 버튼이 제공된다
- [x] 토스트 타입별로 다른 스타일이 적용된다 (success, info, error)

### 심화과제

#### SPA 네비게이션 및 URL 관리

**페이지 이동**

- [x] 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.

**상품 목록 - URL 쿼리 반영**

- [x] 검색어가 URL 쿼리 파라미터에 저장된다
- [x] 카테고리 선택이 URL 쿼리 파라미터에 저장된다
- [x] 상품 옵션이 URL 쿼리 파라미터에 저장된다
- [x] 정렬 조건이 URL 쿼리 파라미터에 저장된다
- [x] 조건 변경 시 URL이 자동으로 업데이트된다
- [x] URL을 통해 현재 검색/필터 상태를 공유할 수 있다

**상품 목록 - 새로고침 시 상태 유지**

- [x] 새로고침 후 URL 쿼리에서 검색어가 복원된다
- [x] 새로고침 후 URL 쿼리에서 카테고리가 복원된다
- [x] 새로고침 후 URL 쿼리에서 옵션 설정이 복원된다
- [x] 새로고침 후 URL 쿼리에서 정렬 조건이 복원된다
- [x] 복원된 조건에 맞는 상품 데이터가 다시 로드된다

**장바구니 - 새로고침 시 데이터 유지**

- [x] 장바구니 내용이 브라우저에 저장된다
- [x] 새로고침 후에도 이전 장바구니 내용이 유지된다
- [x] 장바구니의 선택 상태도 함께 유지된다

**상품 상세 - URL에 ID 반영**

- [x] 상품 상세 페이지 이동 시 상품 ID가 URL 경로에 포함된다 (`/product/{productId}`)
- [x] URL로 직접 접근 시 해당 상품의 상세 페이지가 자동으로 로드된다

**상품 상세 - 새로고침시 유지**

- [x] 새로고침 후에도 URL의 상품 ID를 읽어서 해당 상품 상세 페이지가 유지된다

**404 페이지**

- [x] 존재하지 않는 경로 접근 시 404 에러 페이지가 표시된다
- [x] 홈으로 돌아가기 버튼이 제공된다

#### AI로 한 번 더 구현하기

- [ ] 기존에 구현한 기능을 AI로 다시 구현한다.
- [ ] 이 과정에서 직접 가공하는 것은 최대한 지양한다.

## 과제 셀프회고

### 기술적 성장
이번 과제를 통해 React의 동작 원리를 바닐라 JavaScript로 직접 구현해보며, 
프레임워크가 내부적으로 어떻게 상태를 관리하고 렌더링을 제어하는지를 깊이 이해할 수 있었습니다.  
특히 `useState`, 렌더링 스케줄링, 그리고 라우팅 구조를 직접 설계하면서 단순히 React를 사용하는 수준이 아니라 
“React가 왜 이렇게 설계되었는지”를 체감할 수 있었습니다.  
React 공식 문서에서 강조하는 핵심 개념인 “상태에 따라 UI를 선언적으로 관리한다”는 부분을 직접 코드로 구현하면서, 
**렌더링 최적화와 비동기 렌더링(batch update)**의 중요성을 배웠습니다.  
그리고 React의 Hooks 구조를 모방하기 위해 **렌더 순서를 보장하는 인덱스 관리 로직**과 
**전역 currentComponent 컨텍스트**를 구현하면서 컴포넌트 단위의 독립적인 상태 관리가 왜 필요한지를 이해하게 되었습니다.

---
### 자랑하고 싶은 코드
React의 렌더링 구조를 모방해본 부분입니다.
* 렌더 순서 보장을 위한 Hook 인덱스 관리
* 같은 값일 경우 렌더를 생략하는 Object.is 비교 로직,
* Promise.resolve를 활용한 비동기 렌더링(batch update)

### 개선이 필요하다고 생각하는 코드
라우터 구현 부분에서는 여전히 개선할 곳이 많습니다.
현재는 Router에서 페이지를 렌더링할 때 HTML 문자열을 직접 반환하는 방식이라,
Hook이 작동할 수 있는 렌더 트리 구조가 존재하지 않습니다.
React처럼 컴포넌트 단위로 렌더링 트리를 구성하고, 
각 컴포넌트마다 Hook 컨텍스트를 독립적으로 유지할 수 있는 구조로 리팩토링이 필요하다고 생각합니다.
이벤트 등록을 메인 스크립트에서 한꺼번에 처리하고 있어서, 페이지 단위의 이벤트 관리가 어려운 점도 개선해야 합니다.

### 학습 효과 분석
React의 렌더링이 동기적으로 즉시 실행되지 않고,
Promise 기반의 비동기 스케줄링을 통해 여러 상태 업데이트를 한 번에 처리(batch) 한다는 점이 실무 성능에 큰 의미가 있음을 알게 되었습니다.

### 과제 피드백
제가 부족하여 없습니다...

### AI 활용 경험 공유하기
React를 만든다는 것이 너무 막연하게 느껴졌기 때문에,
AI(ChatGPT)의 도움을 받아 학습 순서와 구현 계획을 세웠습니다.

처음에는 어디서부터 시작해야 할지 감이 없었지만,
AI의 안내를 통해 React의 핵심 요소를 다음과 같은 순서로 접근했습니다.

1. 렌더링 개념 이해
2. 상태 관리(useState) 구조 설계
3. 렌더 스케줄링(batch update) 구현
4. 라우터 및 라이프사이클 구성

이 과정을 통해 막연한 구현 목표를 구체적인 개발 계획으로 바꾸는 법을 배울 수 있었습니다.

또한, AI가 제공한 React 공식 문서 기반의 설명을 참고하여
React의 동작 원리와 제약 조건을 보다 정확히 이해할 수 있었습니다.
이후에는 코드 작성에 어려움이 있을 때마다 작성의 도움을 받을수 있었고, 주석 등 반복적인 것들은 AI 에게 따로 작업을 시켰습니다.

